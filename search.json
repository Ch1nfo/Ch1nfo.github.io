[{"title":"激活函数","url":"/2021/04/15/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/","content":"激活函数之前对于一个函数的精确拟合的方式，对于一个智能体来说比较罕见，我们更多的是判断一个一个东西对，或者不对，最多再多一个不确定。这样的判断方式自然就和先前的拟合函数的方法相差甚远。为了达到这样的效果，我们便使用激活函数对之前的预测模型进行分类。而到此，我们才真正接触到了完整的Rosenblatt感知器模型。\n为了进行分类，我们自然一开始就想到分段函数。但是这种函数在代码的层面上比较难以实现，所以，我们便引入了Logistic函数。\n![屏幕截图 2022-01-04 143240](C:\\Users\\Klsunset\\Pictures\\截图\\屏幕截图 2022-01-04 143240.png)\n当然，我们一般取它的标准形式，即：\n![屏幕截图 2022-01-04 143445](C:\\Users\\Klsunset\\Pictures\\截图\\屏幕截图 2022-01-04 143445.png)\n对于这样的函数我们可以使用nupmy库的exp()函数来实现：1&#x2F;(1+np.exp(-y))。\n这样我们便可以使用它来对预测结果进行分类了\n利用复合函数求导的知识，对加入了激活函数的预测函数求偏导数。\n              deda = -2*(y-a)dadz = a*(1-a)dzdw = xdedw = deda*dadz*dzdwdzdb = 1dedb = deda*dadz*dzdb\n\n再把这段代码加入之前的代码，在进行一些修改，我们可以得到最后的源码：\nimport datasetimport matplotlib.pyplot as pltimport numpy as npxs, ys = dataset.get_beans(100)print(xs)print(ys)plt.title(&quot;STF&quot;, fontsize=12)plt.xlabel(&quot;B&quot;)plt.ylabel(&quot;T&quot;)plt.scatter(xs, ys)w = 0.1b = 0.1y_pre = w*xs + bplt.plot(xs, y_pre)plt.show()for _ in range(5000):\tfor i in range(100):\t\tx = xs[i]\t\ty = ys[i]\t\t\t\tz = w*x + b\t\ta = 1/(1+np.exp(-z))\t\te = (y-a)**2\t\tdeda = -2*(y-a)\t\tdadz = a*(1-a)\t\tdzdw = x\t\tdedw = deda*dadz*dzdw\t\tdzdb = 1\t\tdedb = deda*dadz*dzdb\t\talpha = 0.05\t\tw = w - alpha*dedw\t\tb = b - alpha*dedb\tif _%100 == 0:\t\tplt.clf()\t\tplt.scatter(xs, ys)\t\tz = w*xs + b\t\ta = 1/(1+np.exp(-z))\t\tplt.xlim(0,1)\t\tplt.ylim(0,1.2)\t\tplt.plot(xs, a)\t\tplt.pause(0.01)#暂停0.01秒\n\n运行后可以观察到：![激活函数](C:\\Users\\Klsunset\\Pictures\\Saved Pictures\\激活函数.gif)\n很好的对两类数据进行了分类。\n","categories":["AI"],"tags":["AI"]}]